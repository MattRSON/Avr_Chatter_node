   1               		.file	"avr_uart.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	avr_uart_init
  12               	avr_uart_init:
  13               	.LFB0:
  14               		.file 1 "avr_uart.c"
   1:avr_uart.c    **** #include <avr/io.h>
   2:avr_uart.c    **** 
   3:avr_uart.c    **** #define BAUD 57600
   4:avr_uart.c    **** #define UBRR_VAL ((F_CPU / (16UL * BAUD))-1)
   5:avr_uart.c    **** 
   6:avr_uart.c    **** 
   7:avr_uart.c    **** // Initialize the UART
   8:avr_uart.c    **** void avr_uart_init(void)
   9:avr_uart.c    **** {
  15               		.loc 1 9 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  10:avr_uart.c    ****     // Enable bidirectional UART
  11:avr_uart.c    **** 
  12:avr_uart.c    ****     UCSRB |= (1<<RXEN)|(1<<TXEN);
  21               		.loc 1 12 0
  22 0000 8AB1      		in r24,0xa
  23 0002 8861      		ori r24,lo8(24)
  24 0004 8AB9      		out 0xa,r24
  13:avr_uart.c    ****     //Use 8-bit characters | set mode: 8 data bits, no parity, 1 stop bit
  14:avr_uart.c    ****     UCSRC |= (1<<UCSZ0)|(1<<UCSZ1)|(1<<URSEL);
  25               		.loc 1 14 0
  26 0006 80B5      		in r24,0x20
  27 0008 8668      		ori r24,lo8(-122)
  28 000a 80BD      		out 0x20,r24
  15:avr_uart.c    ****     // Set the Baud rate
  16:avr_uart.c    ****     UBRRH = (UBRR_VAL >> 8);
  29               		.loc 1 16 0
  30 000c 10BC      		out 0x20,__zero_reg__
  17:avr_uart.c    ****     UBRRL = UBRR_VAL;
  31               		.loc 1 17 0
  32 000e 87E0      		ldi r24,lo8(7)
  33 0010 89B9      		out 0x9,r24
  34 0012 0895      		ret
  35               		.cfi_endproc
  36               	.LFE0:
  38               	.global	avr_uart_send_byte
  40               	avr_uart_send_byte:
  41               	.LFB1:
  18:avr_uart.c    **** }
  19:avr_uart.c    **** 
  20:avr_uart.c    **** // Send one char (blocking)
  21:avr_uart.c    **** void avr_uart_send_byte(uint8_t tx_byte)
  22:avr_uart.c    **** {
  42               		.loc 1 22 0
  43               		.cfi_startproc
  44               	.LVL0:
  45               	/* prologue: function */
  46               	/* frame size = 0 */
  47               	/* stack size = 0 */
  48               	.L__stack_usage = 0
  49               	.L3:
  23:avr_uart.c    ****     // Wait to be able to transmit
  24:avr_uart.c    ****     while((UCSRA & (1<<UDRE)) == 0)
  50               		.loc 1 24 0
  51 0014 5D99      		sbic 0xb,5
  52 0016 00C0      		rjmp .L6
  25:avr_uart.c    ****         asm volatile("nop"::);
  53               		.loc 1 25 0
  54               	/* #APP */
  55               	 ;  25 "avr_uart.c" 1
  56 0018 0000      		nop
  57               	 ;  0 "" 2
  58               	/* #NOAPP */
  59 001a 00C0      		rjmp .L3
  60               	.L6:
  26:avr_uart.c    ****     // Put the data into the send buffer
  27:avr_uart.c    ****     UDR = tx_byte;
  61               		.loc 1 27 0
  62 001c 8CB9      		out 0xc,r24
  63 001e 0895      		ret
  64               		.cfi_endproc
  65               	.LFE1:
  67               	.global	avr_uart_receive_byte
  69               	avr_uart_receive_byte:
  70               	.LFB2:
  28:avr_uart.c    **** }
  29:avr_uart.c    **** 
  30:avr_uart.c    **** // Get one char if available, otherwise -1
  31:avr_uart.c    **** int16_t avr_uart_receive_byte(void)
  32:avr_uart.c    **** {
  71               		.loc 1 32 0
  72               		.cfi_startproc
  73               	/* prologue: function */
  74               	/* frame size = 0 */
  75               	/* stack size = 0 */
  76               	.L__stack_usage = 0
  33:avr_uart.c    ****     if(!(UCSRA & (1<<RXC)))
  77               		.loc 1 33 0
  78 0020 5F99      		sbic 0xb,7
  79 0022 00C0      		rjmp .L9
  34:avr_uart.c    ****     {
  35:avr_uart.c    ****         return UDR;
  80               		.loc 1 35 0
  81 0024 8CB1      		in r24,0xc
  82 0026 90E0      		ldi r25,0
  83 0028 0895      		ret
  84               	.L9:
  36:avr_uart.c    ****     }
  37:avr_uart.c    ****     else
  38:avr_uart.c    ****     {
  39:avr_uart.c    ****         return -1;
  85               		.loc 1 39 0
  86 002a 8FEF      		ldi r24,lo8(-1)
  87 002c 9FEF      		ldi r25,lo8(-1)
  40:avr_uart.c    ****     }
  41:avr_uart.c    **** }
  88               		.loc 1 41 0
  89 002e 0895      		ret
  90               		.cfi_endproc
  91               	.LFE2:
  93               	.Letext0:
  94               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 avr_uart.c
     /tmp/ccqTJ4cJ.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccqTJ4cJ.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccqTJ4cJ.s:4      *ABS*:0000003f __SREG__
     /tmp/ccqTJ4cJ.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccqTJ4cJ.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccqTJ4cJ.s:12     .text:00000000 avr_uart_init
     /tmp/ccqTJ4cJ.s:40     .text:00000014 avr_uart_send_byte
     /tmp/ccqTJ4cJ.s:69     .text:00000020 avr_uart_receive_byte

NO UNDEFINED SYMBOLS
